
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>MiniQuest: Complete Technical Documentation</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid="0"
                  id="miniquest-technical-complete"
                  title="MiniQuest: Complete Technical Documentation"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Overview" duration="5">
        <h2 is-upgraded>What is MiniQuest?</h2>
<p>MiniQuest is a <strong>production-ready multi-agent system</strong> that generates personalized travel itineraries using real-time web research and RAG-based personalization. It combines <strong>7 specialized AI agents</strong> coordinated by LangGraph to create complete, research-backed adventure plans.</p>
<h2 is-upgraded>Key Capabilities</h2>
<ul>
<li>Real-time venue research using Tavily API</li>
<li>Multi-agent workflow orchestration with LangGraph</li>
<li>RAG-based personalization using ChromaDB</li>
<li>Google Maps route optimization</li>
<li>Parallel processing with intelligent caching</li>
<li>User authentication and history tracking</li>
<li>Real-time progress tracking</li>
</ul>
<h2 is-upgraded>Technology Stack</h2>
<p><strong>Backend:</strong></p>
<ul>
<li>Python 3.11, FastAPI, LangGraph</li>
<li>AsyncOpenAI, Tavily API</li>
<li>MongoDB Atlas, ChromaDB, Redis</li>
<li>Google Maps API</li>
</ul>
<p><strong>Frontend:</strong></p>
<ul>
<li>React 18 with TypeScript</li>
<li>Vite, Axios, React Router</li>
</ul>
<p><strong>Infrastructure:</strong></p>
<ul>
<li>Docker &amp; Docker Compose</li>
<li>AWS (CloudFront, ECS)</li>
<li>MongoDB Atlas, Redis</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="System Architecture" duration="10">
        <h2 is-upgraded>High-Level Architecture</h2>
<p class="image-container"><img alt="System Architecture" src="img\\8ab22ef87faec2.png"></p>
<p>The system uses a <strong>multi-layer architecture</strong> with clear separation of concerns:</p>
<pre><code>Frontend (React)
    ↓ REST API
FastAPI Backend
    ↓ Orchestration
LangGraph Coordinator
    ↓ Sequential Workflow
7 Specialized Agents
    ↓ Data Layer
MongoDB + Redis + ChromaDB
</code></pre>
<h2 is-upgraded>The 7 Specialized Agents</h2>
<p>Each agent has a <strong>single, well-defined responsibility</strong>:</p>
<ol type="1">
<li><strong>IntentParser</strong> - Extract user preferences from natural language</li>
<li><strong>LocationParser</strong> - Resolve location to coordinates</li>
<li><strong>VenueScout</strong> - Generate 15-20 diverse venue candidates (GPT-4o)</li>
<li><strong>Discovery</strong> - Real-time web search and extract with Tavily (parallel, 8 concurrent)</li>
<li><strong>ResearchSummary</strong> - Synthesize findings into structured data</li>
<li><strong>RoutingAgent</strong> - Calculate optimal routes (Google Maps)</li>
<li><strong>AdventureCreator</strong> - Generate 3 themed adventures (async)</li>
</ol>
<p>Negative : <strong>Key Design Principle:</strong> Each agent is independently testable and can be optimized separately for maximum modularity</p>
<h2 is-upgraded>Data Flow</h2>
<p class="image-container"><img alt="Adventure Generation Flow" src="img\\2a31d0179da0f5be.png"></p>
<p><strong>Complete Generation Pipeline:</strong></p>
<pre><code>User Query
  → IntentParser (extract themes)
  → LocationParser (get coordinates)
  → RAG System (apply personalization)
  → VenueScout (generate venues)
  → Discovery (research in parallel)
  → ResearchSummary (synthesize data)
  → RoutingAgent (calculate routes)
  → AdventureCreator (create 3 adventures)
  → Save metadata to MongoDB
  → Return to user
</code></pre>
<p><strong>Average Processing Time:</strong> ~4.2 seconds (with optimizations)</p>
<h2 is-upgraded>System Components Overview</h2>
<table>
<tr><td colspan="1" rowspan="1"><p>Component</p>
</td><td colspan="1" rowspan="1"><p>Technology</p>
</td><td colspan="1" rowspan="1"><p>Purpose</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>API Server</p>
</td><td colspan="1" rowspan="1"><p>FastAPI</p>
</td><td colspan="1" rowspan="1"><p>REST endpoints</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Coordinator</p>
</td><td colspan="1" rowspan="1"><p>LangGraph</p>
</td><td colspan="1" rowspan="1"><p>Agent orchestration</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Agents</p>
</td><td colspan="1" rowspan="1"><p>OpenAI, Tavily</p>
</td><td colspan="1" rowspan="1"><p>Specialized processing</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>RAG System</p>
</td><td colspan="1" rowspan="1"><p>ChromaDB</p>
</td><td colspan="1" rowspan="1"><p>Personalization</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Auth System</p>
</td><td colspan="1" rowspan="1"><p>JWT, bcrypt</p>
</td><td colspan="1" rowspan="1"><p>Authentication</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Database</p>
</td><td colspan="1" rowspan="1"><p>MongoDB, Redis</p>
</td><td colspan="1" rowspan="1"><p>Persistence, caching</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>Frontend</p>
</td><td colspan="1" rowspan="1"><p>React, TypeScript</p>
</td><td colspan="1" rowspan="1"><p>User interface</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="LangGraph Workflow" duration="12">
        <h2 is-upgraded>State Machine Design</h2>
<p class="image-container"><img alt="LangGraph Workflow" src="img\\1c55f35ce33d356a.png"></p>
<p>LangGraph orchestrates the workflow as a <strong>state graph</strong> with 8 sequential nodes:</p>
<p><strong>Workflow Progression:</strong></p>
<ul>
<li>Node 1: <code>parse_location</code> (14% progress)</li>
<li>Node 2: <code>get_personalization</code> (29% progress)</li>
<li>Node 3: <code>parse_intent</code> (29% progress)</li>
<li>Node 4: <code>scout_venues</code> (43% progress)</li>
<li>Node 5: <code>research_venues</code> (57% progress) - <strong>Parallel</strong></li>
<li>Node 6: <code>summarize_research</code> (71% progress)</li>
<li>Node 7: <code>route_adventures</code> (86% progress)</li>
<li>Node 8: <code>create_adventures</code> (100% progress) - <strong>Async</strong></li>
</ul>
<h2 is-upgraded>State Management</h2>
<p>The workflow maintains <strong>shared state</strong> across all agents:</p>
<pre><code language="language-python" class="language-python">class AdventureState(TypedDict):
    # Input
    user_input: str
    user_address: Optional[str]
    user_id: Optional[str]
    
    # Processing
    target_location: str
    coordinates: Dict
    parsed_preferences: Dict
    scouted_venues: List[Dict]
    researched_venues: List[Dict]
    
    # Output
    final_adventures: List[Dict]
    performance: Dict
</code></pre>
<h2 is-upgraded>Real-Time Progress Tracking</h2>
<p>Progress updates are <strong>streamed</strong> to the frontend:</p>
<pre><code language="language-json" class="language-json">{
  &#34;step&#34;: &#34;research_venues&#34;,
  &#34;agent&#34;: &#34;Discovery&#34;,
  &#34;status&#34;: &#34;in_progress&#34;,
  &#34;message&#34;: &#34;Researching 8 venues...&#34;,
  &#34;progress&#34;: 0.57,
  &#34;details&#34;: {...}
}
</code></pre>
<h2 is-upgraded>Agent Implementations</h2>
<p><strong>IntentParser Agent:</strong></p>
<ul>
<li>Extracts preferences, themes, activities from natural language</li>
<li>Returns structured JSON with user interests</li>
<li>Validates scope (local adventures only)</li>
<li>Provides clarification when needed</li>
</ul>
<p><strong>LocationParser Agent:</strong></p>
<ul>
<li>Resolves location strings to coordinates</li>
<li>Uses OpenAI function calling for geocoding</li>
<li>Validates and returns structured location data</li>
<li>Handles ambiguous locations gracefully</li>
</ul>
<p><strong>VenueScout Agent:</strong></p>
<ul>
<li>Generates 15-20 diverse venue candidates</li>
<li>Enforces category diversity</li>
<li>Includes exact addresses</li>
<li>Uses GPT-4o for generation</li>
<li>Validates venues exist</li>
</ul>
<p><strong>Discovery Agent:</strong></p>
<ul>
<li>Researches venues in parallel (8 concurrent)</li>
<li>Multi-step: Search API → Extract API</li>
<li>Caches results in Redis (24hr TTL)</li>
<li>Graceful error recovery</li>
<li>Smart deduplication</li>
</ul>
<p><strong>ResearchSummary Agent:</strong></p>
<ul>
<li>Synthesizes raw research into structured summaries</li>
<li>Extracts hours, prices, tips, descriptions</li>
<li>Calculates confidence scores</li>
<li>Batch processing (all venues in one call)</li>
<li>Anti-hallucination safeguards</li>
</ul>
<p><strong>RoutingAgent:</strong></p>
<ul>
<li>Generates optimal Google Maps routes</li>
<li>Multiple travel modes (walk, drive, transit)</li>
<li>Waypoint optimization</li>
<li>Shareable route URLs</li>
<li>Distance-based mode recommendations</li>
</ul>
<p><strong>AdventureCreator Agent:</strong></p>
<ul>
<li>Creates 3 themed adventures asynchronously</li>
<li>Integrates all research data</li>
<li>Weaves compelling narratives</li>
<li>Adds route information</li>
<li>Preserves venue research</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Backend Components Deep Dive" duration="15">
        <h2 is-upgraded>3.1 LangGraph Coordinator</h2>
<p><strong>File: </strong><code>backend/app/agents/coordination/langgraph_coordinator.py</code></p>
<p>The coordinator orchestrates the entire multi-agent workflow using LangGraph&#39;s state graph pattern.</p>
<h3 is-upgraded>Architecture</h3>
<pre><code language="language-python" class="language-python">class LangGraphCoordinator:
    &#34;&#34;&#34;
    Orchestrates 7 agents in a sequential workflow with:
    - State management
    - Progress tracking
    - Error handling
    - Performance monitoring
    &#34;&#34;&#34;
</code></pre>
<h3 is-upgraded>Workflow Node Details</h3>
<p><strong>1. parse_location_node</strong></p>
<ul>
<li><strong>Agent:</strong> LocationParserAgent</li>
<li><strong>Input:</strong> User query, optional address</li>
<li><strong>Output:</strong> Validated location with coordinates</li>
<li><strong>Progress:</strong> 14%</li>
<li><strong>Error Handling:</strong> Defaults to Boston if parsing fails</li>
</ul>
<p><strong>2. get_personalization_node</strong></p>
<ul>
<li><strong>Agent:</strong> RAG System (ChromaDB)</li>
<li><strong>Input:</strong> User ID, location, preferences</li>
<li><strong>Output:</strong> Historical preferences, favorite themes</li>
<li><strong>Progress:</strong> 29%</li>
<li><strong>Optimization:</strong> Queries vector database for semantic matches</li>
</ul>
<p><strong>3. parse_intent_node</strong></p>
<ul>
<li><strong>Agent:</strong> IntentParserAgent</li>
<li><strong>Input:</strong> User query</li>
<li><strong>Output:</strong> Extracted themes, activities, constraints</li>
<li><strong>Progress:</strong> 29%</li>
<li><strong>Validation:</strong> Checks if query is in scope</li>
</ul>
<p><strong>4. scout_venues_node</strong></p>
<ul>
<li><strong>Agent:</strong> VenueScoutAgent</li>
<li><strong>Input:</strong> Preferences, location</li>
<li><strong>Output:</strong> 15-20 candidate venues with addresses</li>
<li><strong>Progress:</strong> 43%</li>
<li><strong>Quality Control:</strong> Enforces category diversity</li>
</ul>
<p><strong>5. research_venues_node</strong></p>
<ul>
<li><strong>Agent:</strong> DiscoveryAgent (parallel)</li>
<li><strong>Input:</strong> Venue list</li>
<li><strong>Output:</strong> Current hours, prices, reviews, descriptions</li>
<li><strong>Progress:</strong> 57%</li>
<li><strong>Optimization:</strong> Runs 8 venues concurrently</li>
<li><strong>Caching:</strong> Redis-based with 24hr TTL</li>
</ul>
<p><strong>6. summarize_research_node</strong></p>
<ul>
<li><strong>Agent:</strong> ResearchSummaryAgent</li>
<li><strong>Input:</strong> Raw research results</li>
<li><strong>Output:</strong> Structured venue summaries</li>
<li><strong>Progress:</strong> 71%</li>
<li><strong>Batch Processing:</strong> All venues in single OpenAI call</li>
</ul>
<p><strong>7. route_adventures_node</strong></p>
<ul>
<li><strong>Agent:</strong> EnhancedRoutingAgent</li>
<li><strong>Input:</strong> Researched venues</li>
<li><strong>Output:</strong> Google Maps routes, travel times</li>
<li><strong>Progress:</strong> 86%</li>
<li><strong>Features:</strong> Waypoint optimization, mode selection</li>
</ul>
<p><strong>8. create_adventures_node</strong></p>
<ul>
<li><strong>Agent:</strong> AdventureCreatorAgent (async)</li>
<li><strong>Input:</strong> All previous outputs</li>
<li><strong>Output:</strong> 3 complete themed adventures</li>
<li><strong>Progress:</strong> 100%</li>
<li><strong>Optimization:</strong> Async generation of 3 adventures</li>
</ul>
<h3 is-upgraded>State Transitions</h3>
<pre><code language="language-python" class="language-python">workflow.add_edge(START, &#34;parse_location&#34;)
workflow.add_edge(&#34;parse_location&#34;, &#34;get_personalization&#34;)
workflow.add_edge(&#34;get_personalization&#34;, &#34;parse_intent&#34;)
workflow.add_edge(&#34;parse_intent&#34;, &#34;scout_venues&#34;)
workflow.add_edge(&#34;scout_venues&#34;, &#34;research_venues&#34;)
workflow.add_edge(&#34;research_venues&#34;, &#34;summarize_research&#34;)
workflow.add_edge(&#34;summarize_research&#34;, &#34;route_adventures&#34;)
workflow.add_edge(&#34;route_adventures&#34;, &#34;create_adventures&#34;)
workflow.add_edge(&#34;create_adventures&#34;, END)
</code></pre>
<h3 is-upgraded>Performance Tracking</h3>
<pre><code language="language-python" class="language-python">def _track_timing(self, step: str, duration: float):
    &#34;&#34;&#34;Track execution time per node&#34;&#34;&#34;
    self.timing_data[step] = duration
</code></pre>
<h2 is-upgraded>3.2 Base Agent</h2>
<p><strong>File: </strong><code>backend/app/agents/base.py</code></p>
<pre><code language="language-python" class="language-python">class BaseAgent:
    &#34;&#34;&#34;
    Abstract base class for all agents
    
    Features:
    - Standardized logging
    - Error handling
    - Validation framework
    &#34;&#34;&#34;
    
    def __init__(self, name: str):
        self.name = name
        self.logger = logging.getLogger(f&#34;agent.{name.lower()}&#34;)
    
    async def process(self, input_data: Dict) -&gt; Dict:
        &#34;&#34;&#34;Abstract method - implemented by each agent&#34;&#34;&#34;
        raise NotImplementedError
</code></pre>
<h2 is-upgraded>3.3 Intent Parser Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/intent/intent_parser.py</code></p>
<p><strong>Purpose:</strong> Extract structured preferences from natural language</p>
<p><strong>Process:</strong></p>
<ol type="1">
<li>Receive user query</li>
<li>Validate scope (local adventures only)</li>
<li>Call OpenAI GPT-4o-mini with structured prompt</li>
<li>Parse JSON response</li>
<li>Validate extracted fields</li>
</ol>
<p><strong>Scope Validation:</strong></p>
<pre><code language="language-python" class="language-python">def _validate_scope(self, user_input: str) -&gt; Dict:
    &#34;&#34;&#34;Check if query is within MiniQuest scope&#34;&#34;&#34;
    
    # Out of scope: multi-day trips, international travel
    # In scope: local 2-6 hour adventures
    
    if &#34;europe&#34; in user_input_lower or &#34;asia&#34; in user_input_lower:
        return {
            &#34;valid&#34;: False,
            &#34;message&#34;: &#34;MiniQuest operates in Boston and NYC only&#34;
        }
    
    return {&#34;valid&#34;: True}
</code></pre>
<p><strong>Input:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;user_input&#34;: &#34;coffee shops and art galleries in Boston&#34;
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;preferences&#34;: [&#34;coffee&#34;, &#34;art&#34;, &#34;culture&#34;],
    &#34;activities&#34;: [&#34;cafe&#34;, &#34;gallery&#34;, &#34;museum&#34;],
    &#34;themes&#34;: [&#34;artistic&#34;, &#34;creative&#34;, &#34;local&#34;],
    &#34;constraints&#34;: {
        &#34;budget&#34;: &#34;moderate&#34;,
        &#34;duration&#34;: &#34;half_day&#34;
    },
    &#34;scope_valid&#34;: True
}
</code></pre>
<p><strong>OpenAI Prompt Structure:</strong></p>
<pre><code language="language-python" class="language-python">system_prompt = &#34;&#34;&#34;
Extract user preferences from the query.
Return JSON with:
- preferences: List of interests
- activities: Specific activity types
- themes: Overall themes
- constraints: Any limitations

SCOPE: Only local, same-day adventures (2-6 hours)
&#34;&#34;&#34;
</code></pre>
<h2 is-upgraded>3.4 Location Parser Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/location/location_parser.py</code></p>
<p><strong>Purpose:</strong> Resolve and validate locations with coordinates</p>
<p><strong>Features:</strong></p>
<ul>
<li>Geocoding via OpenAI function calling</li>
<li>Address validation</li>
<li>Coordinate extraction</li>
<li>Fallback to default location</li>
</ul>
<p><strong>Process:</strong></p>
<ol type="1">
<li>Extract location from query or use provided address</li>
<li>Call OpenAI with geocoding function</li>
<li>Validate coordinates</li>
<li>Return structured location data</li>
</ol>
<p><strong>OpenAI Function Definition:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;name&#34;: &#34;geocode_location&#34;,
    &#34;description&#34;: &#34;Get coordinates for a location&#34;,
    &#34;parameters&#34;: {
        &#34;type&#34;: &#34;object&#34;,
        &#34;properties&#34;: {
            &#34;location&#34;: {&#34;type&#34;: &#34;string&#34;},
            &#34;city&#34;: {&#34;type&#34;: &#34;string&#34;},
            &#34;state&#34;: {&#34;type&#34;: &#34;string&#34;},
            &#34;latitude&#34;: {&#34;type&#34;: &#34;number&#34;},
            &#34;longitude&#34;: {&#34;type&#34;: &#34;number&#34;}
        }
    }
}
</code></pre>
<p><strong>Output:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;location&#34;: &#34;Boston, MA&#34;,
    &#34;coordinates&#34;: {
        &#34;lat&#34;: 42.3601,
        &#34;lon&#34;: -71.0589
    },
    &#34;city&#34;: &#34;Boston&#34;,
    &#34;state&#34;: &#34;MA&#34;,
    &#34;country&#34;: &#34;USA&#34;
}
</code></pre>
<h2 is-upgraded>3.5 Venue Scout Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/scouting/venue_scout.py</code></p>
<p><strong>Purpose:</strong> Generate diverse venue candidates using GPT-4o</p>
<p><strong>Strategy:</strong></p>
<ul>
<li>Request 15-20 venues per generation</li>
<li>Enforce diversity across categories</li>
<li>Include specific addresses</li>
<li>Validate venues exist</li>
</ul>
<p><strong>OpenAI Prompt:</strong></p>
<pre><code language="language-python" class="language-python">system_prompt = f&#34;&#34;&#34;
Generate 15-20 diverse venues in {location} matching preferences: {preferences}

Requirements:
- Mix of popular and hidden gems
- Include EXACT addresses
- Diverse categories (coffee, museums, parks, etc.)
- Real, verifiable venues
- No chains unless highly rated

Return JSON array of venues with:
- name: Venue name
- address: Full street address
- category: Type of venue
- description: Brief description
&#34;&#34;&#34;
</code></pre>
<p><strong>Category Diversity Enforcement:</strong></p>
<pre><code language="language-python" class="language-python">def _ensure_diversity(venues: List[Dict]) -&gt; List[Dict]:
    &#34;&#34;&#34;Ensure no category dominates&#34;&#34;&#34;
    category_counts = {}
    filtered_venues = []
    
    for venue in venues:
        category = venue.get(&#34;category&#34;)
        if category_counts.get(category, 0) &lt; 4:
            filtered_venues.append(venue)
            category_counts[category] = category_counts.get(category, 0) + 1
    
    return filtered_venues
</code></pre>
<p><strong>Output:</strong></p>
<pre><code language="language-python" class="language-python">[
    {
        &#34;name&#34;: &#34;Thinking Cup&#34;,
        &#34;address&#34;: &#34;165 Tremont St, Boston, MA 02111&#34;,
        &#34;category&#34;: &#34;coffee_shop&#34;,
        &#34;description&#34;: &#34;Artisan coffee with pastries&#34;
    },
    # ... 14-19 more venues
]
</code></pre>
<h2 is-upgraded>3.6 Discovery Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/research/discovery_agent.py</code></p>
<p><strong>Purpose:</strong> Real-time web research on venues with caching</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Parallel Processing:</strong> 8 concurrent venue researches</li>
<li><strong>Smart Caching:</strong> Redis with 24-hour TTL</li>
<li><strong>Multi-Step Research:</strong> Search → Extract for depth</li>
<li><strong>Error Recovery:</strong> Graceful degradation on API failures</li>
</ul>
<p><strong>Process Flow:</strong></p>
<pre><code language="language-python" class="language-python">async def research_venue(venue: Dict) -&gt; Dict:
    # 1. Check cache
    cache_key = f&#34;venue:{venue[&#39;name&#39;]}:{location}:{date}&#34;
    cached = await redis.get(cache_key)
    if cached:
        return cached
    
    # 2. Tavily Search API
    search_results = tavily.search(
        query=f&#34;{venue[&#39;name&#39;]} {location} hours prices reviews&#34;,
        search_depth=&#34;advanced&#34;,
        max_results=5
    )
    
    # 3. Tavily Extract API (deep dive)
    extract_results = tavily.extract(
        urls=[result[&#39;url&#39;] for result in search_results],
        include_raw_content=False
    )
    
    # 4. Synthesize and cache
    research_data = synthesize(search_results, extract_results)
    await redis.set(cache_key, research_data, ex=86400)
    
    return research_data
</code></pre>
<p><strong>Parallel Execution:</strong></p>
<pre><code language="language-python" class="language-python">async def process(self, input_data: Dict) -&gt; Dict:
    venues = input_data[&#34;venues&#34;]
    
    # Research 8 venues concurrently
    async with asyncio.TaskGroup() as tg:
        tasks = [
            tg.create_task(self._research_venue(v))
            for v in venues
        ]
    
    return {&#34;researched_venues&#34;: [t.result() for t in tasks]}
</code></pre>
<p><strong>Cache Statistics:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;total_requests&#34;: 100,
    &#34;cache_hits&#34;: 91,
    &#34;cache_misses&#34;: 9,
    &#34;hit_rate&#34;: &#34;91.0%&#34;,
    &#34;time_saved_seconds&#34;: 182.4
}
</code></pre>
<p><strong>Output Structure:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;venue_name&#34;: &#34;Thinking Cup&#34;,
    &#34;current_info&#34;: &#34;Open today until 6 PM&#34;,
    &#34;hours_info&#34;: &#34;Mon-Fri: 7 AM - 6 PM, Sat-Sun: 8 AM - 5 PM&#34;,
    &#34;visitor_tips&#34;: [
        &#34;Try the cappuccino&#34;,
        &#34;Arrive early on weekends&#34;,
        &#34;Free WiFi available&#34;
    ],
    &#34;venue_summary&#34;: &#34;Popular artisan coffee shop...&#34;,
    &#34;research_confidence&#34;: 0.89,
    &#34;total_insights&#34;: 12,
    &#34;top_source&#34;: &#34;thinkingcup.com&#34;
}
</code></pre>
<h2 is-upgraded>3.7 Research Summary Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/research/research_summary_agent.py</code></p>
<p><strong>Purpose:</strong> Synthesize raw research into structured summaries</p>
<p><strong>Optimization:</strong> Batch processing - all venues in single OpenAI call</p>
<p><strong>Process:</strong></p>
<ol type="1">
<li>Receive raw Tavily results per venue</li>
<li>Batch all venues into single prompt</li>
<li>Extract key information using GPT-4o-mini</li>
<li>Structure into consistent format</li>
<li>Calculate confidence scores</li>
</ol>
<p><strong>OpenAI Prompt:</strong></p>
<pre><code language="language-python" class="language-python">system_prompt = &#34;&#34;&#34;
Analyze venue research and extract for each venue:
- Practical info (hours, prices, admission)
- Insider tips (3-4 actionable tips)
- Best time to visit
- What makes it special

Format as JSON array with one entry per venue.
Confidence: Rate 0-1 based on data quality.

CRITICAL: For free venues, never invent admission prices.
If hours unknown, say &#34;Call ahead to confirm hours&#34;.
&#34;&#34;&#34;
</code></pre>
<p><strong>Anti-Hallucination Safeguards:</strong></p>
<pre><code language="language-python" class="language-python">def _validate_summary(summary: Dict, raw_research: Dict) -&gt; Dict:
    &#34;&#34;&#34;Prevent hallucination of venue details&#34;&#34;&#34;
    
    # If no price data found, don&#39;t invent it
    if not raw_research.get(&#34;pricing_info&#34;):
        summary[&#34;practical_info&#34;][&#34;admission&#34;] = &#34;Check venue website&#34;
    
    # If hours unclear, be honest
    if summary.get(&#34;confidence&#34;) &lt; 0.5:
        summary[&#34;practical_info&#34;][&#34;hours&#34;] = &#34;Call ahead to confirm&#34;
    
    return summary
</code></pre>
<p><strong>Output:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;venue_name&#34;: &#34;Museum of Fine Arts&#34;,
    &#34;visitor_summary&#34;: &#34;World-class art museum with 450,000 works...&#34;,
    &#34;key_highlights&#34;: [
        &#34;Impressionist collection&#34;,
        &#34;Ancient Egyptian artifacts&#34;,
        &#34;Contemporary wing&#34;
    ],
    &#34;practical_info&#34;: {
        &#34;hours&#34;: &#34;Mon-Fri: 10 AM - 5 PM&#34;,
        &#34;admission&#34;: &#34;$27 adults, $25 seniors&#34;,
        &#34;best_time&#34;: &#34;Weekday mornings&#34;,
        &#34;typical_duration&#34;: &#34;2-3 hours&#34;,
        &#34;insider_tips&#34;: [
            &#34;Free admission Wednesdays after 4 PM&#34;,
            &#34;Start with contemporary wing&#34;,
            &#34;Café on ground floor for breaks&#34;
        ]
    },
    &#34;confidence_notes&#34;: &#34;High confidence (12 sources)&#34;,
    &#34;total_insights&#34;: 12
}
</code></pre>
<h2 is-upgraded>3.8 Routing Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/routing/enhanced_routing_agent.py</code></p>
<p><strong>Purpose:</strong> Generate optimal routes using Google Maps Directions API</p>
<p><strong>Key Features:</strong></p>
<ul>
<li>Waypoint optimization</li>
<li>Multiple travel modes (driving, walking, transit)</li>
<li>Distance-based mode recommendations</li>
<li>Fallback for cross-city travel</li>
</ul>
<p><strong>Process:</strong></p>
<pre><code language="language-python" class="language-python">async def calculate_route(venues: List[Dict]) -&gt; Dict:
    # 1. Extract coordinates
    waypoints = [v[&#39;coordinates&#39;] for v in venues]
    
    # 2. Determine optimal mode
    total_distance = calculate_distance(waypoints)
    if total_distance &lt; 3:
        mode = &#34;walking&#34;
    elif total_distance &lt; 10:
        mode = &#34;driving&#34;
    else:
        mode = &#34;transit&#34;
    
    # 3. Call Google Maps Directions API
    result = gmaps.directions(
        origin=waypoints[0],
        destination=waypoints[-1],
        waypoints=waypoints[1:-1],
        mode=mode,
        optimize_waypoints=True
    )
    
    # 4. Generate shareable URL
    route_url = generate_google_maps_url(waypoints, mode)
    
    return {
        &#34;route_url&#34;: route_url,
        &#34;mode&#34;: mode,
        &#34;total_distance&#34;: total_distance,
        &#34;estimated_time&#34;: result[&#39;legs&#39;][0][&#39;duration&#39;][&#39;text&#39;],
        &#34;optimized_order&#34;: result[&#39;waypoint_order&#39;]
    }
</code></pre>
<p><strong>URL Generation:</strong></p>
<pre><code language="language-python" class="language-python">def generate_google_maps_url(waypoints, mode):
    &#34;&#34;&#34;
    Generate shareable Google Maps URL
    
    Format: https://www.google.com/maps/dir/?api=1
            &amp;origin=42.3601,-71.0589
            &amp;destination=42.3584,-71.0598
            &amp;waypoints=42.3593,-71.0603|...
            &amp;travelmode=walking
    &#34;&#34;&#34;
    origin = f&#34;{waypoints[0][&#39;lat&#39;]},{waypoints[0][&#39;lon&#39;]}&#34;
    destination = f&#34;{waypoints[-1][&#39;lat&#39;]},{waypoints[-1][&#39;lon&#39;]}&#34;
    waypoints_str = &#34;|&#34;.join([
        f&#34;{w[&#39;lat&#39;]},{w[&#39;lon&#39;]}&#34; 
        for w in waypoints[1:-1]
    ])
    
    return (
        f&#34;https://www.google.com/maps/dir/?api=1&#34;
        f&#34;&amp;origin={origin}&#34;
        f&#34;&amp;destination={destination}&#34;
        f&#34;&amp;waypoints={waypoints_str}&#34;
        f&#34;&amp;travelmode={mode}&#34;
    )
</code></pre>
<p><strong>Output:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;routing_available&#34;: true,
    &#34;primary_route_url&#34;: &#34;https://www.google.com/maps/dir/?api=1...&#34;,
    &#34;recommended_mode&#34;: &#34;walking&#34;,
    &#34;distance_category&#34;: &#34;walkable&#34;,
    &#34;travel_options&#34;: [
        {
            &#34;mode&#34;: &#34;walking&#34;,
            &#34;url&#34;: &#34;...&#34;,
            &#34;description&#34;: &#34;~2.3 miles, 45 min&#34;,
            &#34;recommended&#34;: true
        },
        {
            &#34;mode&#34;: &#34;transit&#34;,
            &#34;url&#34;: &#34;...&#34;,
            &#34;description&#34;: &#34;Use Red Line&#34;,
            &#34;recommended&#34;: false
        }
    ],
    &#34;optimized_order&#34;: [0, 2, 1, 3]
}
</code></pre>
<h2 is-upgraded>3.9 Adventure Creator Agent Details</h2>
<p><strong>File: </strong><code>backend/app/agents/creation/adventure_creator.py</code></p>
<p><strong>Purpose:</strong> Generate final themed adventures with narratives</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Async execution:</strong> Uses AsyncOpenAI for speed</li>
<li><strong>Theme generation:</strong> Creates unique themes per adventure</li>
<li><strong>Narrative weaving:</strong> Integrates research into stories</li>
<li><strong>Research preservation:</strong> Maintains venue details</li>
</ul>
<p><strong>Process:</strong></p>
<pre><code language="language-python" class="language-python">async def create_adventures(
    researched_venues: List[Dict],
    enhanced_locations: List[Dict],
    preferences: Dict,
    personalization: Dict
) -&gt; List[Dict]:
    
    # 1. Generate 3 themed adventures using GPT-4o
    adventures = await self._generate_base_adventures(
        researched_venues, 
        preferences,
        personalization
    )
    
    # 2. Integrate research data
    for adventure in adventures:
        adventure = self._integrate_research(
            adventure, 
            researched_venues
        )
    
    # 3. Add route information
    for adventure in adventures:
        adventure = self._add_routing(
            adventure,
            enhanced_locations
        )
    
    return adventures
</code></pre>
<p><strong>GPT-4o Prompt Structure:</strong></p>
<pre><code language="language-python" class="language-python">system_prompt = &#34;&#34;&#34;
Create 3 unique themed adventures from provided venues.

Requirements:
- Different theme per adventure (e.g., &#34;Coffee &amp; Culture&#34;, &#34;Historic Tour&#34;, &#34;Hidden Gems&#34;)
- 4-6 hour duration
- Compelling narrative with storytelling
- Specific timeline (e.g., &#34;10:00 AM - Coffee at...&#34;)
- Insider tips integration
- Budget estimate

CRITICAL: Only use provided venues. No hallucinations.
Each adventure should feel distinct and exciting.

Return JSON with structure:
{
    &#34;title&#34;: &#34;Coffee &amp; Culture Tour&#34;,
    &#34;theme&#34;: &#34;Artistic Coffee Journey&#34;,
    &#34;tagline&#34;: &#34;Discover Boston&#39;s café culture and artistic soul&#34;,
    &#34;description&#34;: &#34;A half-day adventure blending...&#34;,
    &#34;duration&#34;: 5,
    &#34;cost&#34;: 40,
    &#34;steps&#34;: [
        {
            &#34;time&#34;: &#34;10:00 AM&#34;,
            &#34;activity&#34;: &#34;Morning Coffee&#34;,
            &#34;details&#34;: &#34;Start your day at Thinking Cup...&#34;,
            &#34;venue_ref&#34;: &#34;Thinking Cup&#34;
        }
    ]
}
&#34;&#34;&#34;
</code></pre>
<p><strong>Research Integration:</strong></p>
<pre><code language="language-python" class="language-python">def _integrate_research(adventure, researched_venues):
    &#34;&#34;&#34;Add research summaries to adventure steps&#34;&#34;&#34;
    for step in adventure[&#39;steps&#39;]:
        venue_name = step.get(&#39;venue_ref&#39;)
        research = find_research(venue_name, researched_venues)
        
        if research:
            step[&#39;venue_research&#39;] = {
                &#39;current_info&#39;: research[&#39;current_info&#39;],
                &#39;hours_info&#39;: research[&#39;hours_info&#39;],
                &#39;visitor_tips&#39;: research[&#39;visitor_tips&#39;],
                &#39;venue_summary&#39;: research[&#39;venue_summary&#39;],
                &#39;research_confidence&#39;: research[&#39;research_confidence&#39;]
            }
    
    return adventure
</code></pre>
<p><strong>Final Adventure Structure:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;title&#34;: &#34;Coffee &amp; Culture Tour&#34;,
    &#34;theme&#34;: &#34;Artistic Coffee Journey&#34;,
    &#34;tagline&#34;: &#34;Discover Boston&#39;s café culture and artistic soul&#34;,
    &#34;description&#34;: &#34;A half-day adventure blending artisan coffee...&#34;,
    &#34;duration&#34;: 4.5,
    &#34;cost&#34;: 35,
    &#34;steps&#34;: [
        {
            &#34;time&#34;: &#34;10:00 AM&#34;,
            &#34;activity&#34;: &#34;Morning Coffee at Thinking Cup&#34;,
            &#34;details&#34;: &#34;Start your day at this beloved South End café...&#34;,
            &#34;insider_tip&#34;: &#34;Try their signature cappuccino and arrive before 11 AM&#34;,
            &#34;venue_research&#34;: {
                &#34;current_info&#34;: &#34;Open today until 6 PM&#34;,
                &#34;hours_info&#34;: &#34;Mon-Fri: 7 AM - 6 PM&#34;,
                &#34;visitor_tips&#34;: [
                    &#34;Arrive before 11 AM to avoid crowds&#34;,
                    &#34;Try the pastries from their in-house baker&#34;
                ],
                &#34;venue_summary&#34;: &#34;Popular artisan coffee shop known for...&#34;,
                &#34;research_confidence&#34;: 0.89
            }
        },
        {
            &#34;time&#34;: &#34;11:30 AM&#34;,
            &#34;activity&#34;: &#34;Art at the MFA&#34;,
            &#34;details&#34;: &#34;Explore the Museum of Fine Arts...&#34;,
            &#34;insider_tip&#34;: &#34;Start with the contemporary wing&#34;,
            &#34;venue_research&#34;: {...}
        }
    ],
    &#34;map_url&#34;: &#34;https://www.google.com/maps/dir/?...&#34;,
    &#34;routing_info&#34;: {
        &#34;routing_available&#34;: true,
        &#34;recommended_mode&#34;: &#34;walking&#34;,
        &#34;total_distance&#34;: &#34;2.3 miles&#34;,
        &#34;estimated_time&#34;: &#34;45 minutes&#34;
    },
    &#34;venues_research&#34;: [/* full research data for all venues */]
}
</code></pre>
<h2 is-upgraded>3.10 Model Selection Strategy</h2>
<p>MiniQuest uses different OpenAI models strategically:</p>
<p><strong>GPT-4o-mini</strong> (Cost-effective):</p>
<ul>
<li>Intent parsing and validation</li>
<li>Location parsing</li>
<li>Quick classification tasks</li>
<li>~75% cheaper than GPT-4o</li>
</ul>
<p><strong>GPT-4o</strong> (Quality-focused):</p>
<ul>
<li>Venue scouting (requires creativity and local knowledge)</li>
<li>Adventure creation (narrative generation)</li>
<li>Research summarization</li>
<li>Tasks requiring deep reasoning</li>
</ul>
<p>This hybrid approach balances cost (~60% savings) with quality where it matters most.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Tavily Search Integration" duration="10">
        <h2 is-upgraded>Why Tavily?</h2>
<p>Tavily provides <strong>real-time web data</strong> that traditional databases can&#39;t offer:</p>
<ul>
<li>Current venue hours (changes daily)</li>
<li>Live prices and deals</li>
<li>Recent reviews and ratings</li>
<li>Up-to-date event information</li>
</ul>
<h2 is-upgraded>Multi-Step Research Strategy</h2>
<p><strong>Step 1: Tavily Search API</strong></p>
<pre><code language="language-python" class="language-python">search_results = tavily.search(
    query=f&#34;{venue_name} {location} hours prices reviews&#34;,
    search_depth=&#34;advanced&#34;,
    max_results=5
)
</code></pre>
<p>Returns top 5 web pages with relevant venue information.</p>
<p><strong>Step 2: Tavily Extract API</strong></p>
<pre><code language="language-python" class="language-python">extract_results = tavily.extract(
    urls=[result[&#39;url&#39;] for result in search_results],
    include_raw_content=False
)
</code></pre>
<p>Deep dive into content for detailed information.</p>
<p><strong>Step 3: Synthesize &amp; Cache</strong></p>
<pre><code language="language-python" class="language-python">research_data = synthesize(search_results, extract_results)
await redis.set(cache_key, research_data, ex=86400)  # 24hr TTL
</code></pre>
<p>Structure data and cache for 24 hours.</p>
<h2 is-upgraded>Research Output Structure</h2>
<p>Each venue receives <strong>comprehensive search data</strong>:</p>
<pre><code language="language-json" class="language-json">{
  &#34;venue_name&#34;: &#34;Thinking Cup&#34;,
  &#34;current_info&#34;: &#34;Open today until 6 PM&#34;,
  &#34;hours_info&#34;: &#34;Mon-Fri: 7 AM - 6 PM&#34;,
  &#34;visitor_tips&#34;: [
    &#34;Try the cappuccino&#34;,
    &#34;Arrive before 11 AM to avoid crowds&#34;,
    &#34;Free WiFi available&#34;
  ],
  &#34;venue_summary&#34;: &#34;Popular artisan coffee shop...&#34;,
  &#34;research_confidence&#34;: 0.89,
  &#34;total_insights&#34;: 12,
  &#34;top_source&#34;: &#34;thinkingcup.com&#34;
}
</code></pre>
<h2 is-upgraded>API Call Optimization</h2>
<p><strong>Per Adventure Generation:</strong></p>
<ul>
<li>Tavily Search calls: ~10</li>
<li>Tavily Extract calls: ~10</li>
<li><strong>Total API calls: ~20</strong></li>
</ul>
<p><strong>With 90% cache hit rate:</strong></p>
<ul>
<li>Actual API calls: ~2-3</li>
<li><strong>Cost savings: 85-90%</strong></li>
</ul>
<p>Positive : Smart caching reduces Tavily API costs by up to 90% while maintaining data freshness with 24-hour TTL</p>


      </google-codelab-step>
    
      <google-codelab-step label="Performance Optimizations" duration="10">
        <h2 is-upgraded>System Optimizations</h2>
<p>The system implements several key optimizations to improve performance and reduce API costs:</p>
<h2 is-upgraded>Optimization #1: Parallel Research</h2>
<p class="image-container"><img alt="Parallel Research" src="img\\aabfab71b0429ac8.png"></p>
<p><strong>Sequential Processing:</strong></p>
<pre><code>Venue 1: researched
Venue 2: researched
...
Venue 8: researched
Process sequentially
</code></pre>
<p><strong>Parallel Processing:</strong></p>
<pre><code language="language-python" class="language-python">async with asyncio.TaskGroup() as tg:
    tasks = [tg.create_task(research_venue(v)) 
             for v in venues]

# All 8 venues researched concurrently
</code></pre>
<p><strong>Benefit:</strong> Multiple venues researched simultaneously instead of one-by-one</p>
<h2 is-upgraded>Optimization #2: Redis Caching</h2>
<p class="image-container"><img alt="Research Caching" src="img\\a7bf98c2dbbfa003.png"></p>
<p><strong>Cache Strategy:</strong></p>
<ul>
<li><strong>Key format: </strong><code>venue:{name}:{location}:{date}</code></li>
<li><strong>TTL:</strong> 24 hours</li>
<li><strong>Purpose:</strong> Avoid re-researching the same venue multiple times</li>
</ul>
<p><strong>Cache Hit Behavior:</strong></p>
<ul>
<li>Cache hit: Returns stored data immediately</li>
<li>Cache miss: Performs fresh Tavily research</li>
</ul>
<p><strong>Example Cache Statistics:</strong></p>
<pre><code language="language-python" class="language-python">{
    &#34;total_requests&#34;: 1000,
    &#34;cache_hits&#34;: 910,
    &#34;cache_misses&#34;: 90,
    &#34;hit_rate&#34;: &#34;91.0%&#34;
}
</code></pre>
<h2 is-upgraded>Optimization #3: Async Adventure Creation</h2>
<p><strong>Sequential Creation:</strong></p>
<pre><code>Adventure 1: created
Adventure 2: created
Adventure 3: created
Process one at a time
</code></pre>
<p><strong>Async Creation:</strong></p>
<pre><code language="language-python" class="language-python">adventures = await asyncio.gather(*[
    create_single(theme) for theme in themes
])
# All 3 adventures created concurrently
</code></pre>
<p><strong>Benefit:</strong> Multiple adventures generated simultaneously using AsyncOpenAI</p>
<h2 is-upgraded>Optimization Summary</h2>
<p>Positive : The system uses parallel processing, intelligent caching, and async operations to optimize the adventure generation pipeline</p>


      </google-codelab-step>
    
      <google-codelab-step label="RAG Personalization" duration="10">
        <h2 is-upgraded>How RAG Works</h2>
<p class="image-container"><img alt="RAG Architecture" src="img\\b6a0cf415ac3c0de.png"></p>
<p>The RAG system <strong>learns from user behavior</strong>:</p>
<p><strong>Workflow:</strong></p>
<ol type="1">
<li>User saves adventure → Stored in ChromaDB with embeddings</li>
<li>Next query → Retrieve similar past adventures</li>
<li>Extract patterns → Favorite themes, venues, locations</li>
<li>Enhance search → Weight recommendations toward preferences</li>
</ol>
<p class="image-container"><img alt="RAG Personalization Flow" src="img\\80aa59c4d9df8d95.png"></p>
<h2 is-upgraded>ChromaDB Collections</h2>
<p><strong>Collection 1: user_adventure_history</strong></p>
<ul>
<li>Stores saved adventures with ratings</li>
<li>OpenAI embeddings for semantic search</li>
<li>Metadata: user_id, location, rating, timestamp</li>
</ul>
<p><strong>Collection 2: dynamic_location_tips</strong></p>
<ul>
<li>Cached insider tips from Tavily</li>
<li>Categorized by location and type</li>
<li>Authenticity scoring</li>
</ul>
<h2 is-upgraded>Implementation Details</h2>
<p><strong>Storing Adventures:</strong></p>
<pre><code language="language-python" class="language-python">def store_user_adventure(user_id, adventure_data, rating):
    adventure_doc = f&#34;&#34;&#34;
    Title: {adventure_data[&#39;title&#39;]}
    Theme: {adventure_data[&#39;theme&#39;]}
    Venues: {&#39;, &#39;.join([v[&#39;name&#39;] for v in venues])}
    Rating: {rating}/5
    &#34;&#34;&#34;
    
    self.user_history_collection.add(
        ids=[f&#34;user_{user_id}_adventure_{timestamp}&#34;],
        documents=[adventure_doc],
        metadatas=[{
            &#34;user_id&#34;: user_id,
            &#34;rating&#34;: rating,
            &#34;location&#34;: location
        }]
    )
</code></pre>
<p><strong>Retrieving Personalization:</strong></p>
<pre><code language="language-python" class="language-python">def get_user_personalization(user_id, location):
    results = self.user_history_collection.query(
        query_texts=[f&#34;adventures in {location}&#34;],
        where={&#34;user_id&#34;: user_id},
        n_results=20
    )
    
    return {
        &#34;favorite_themes&#34;: extract_themes(results),
        &#34;avg_rating&#34;: calculate_avg_rating(results),
        &#34;total_adventures&#34;: len(results)
    }
</code></pre>
<h2 is-upgraded>Example Personalization</h2>
<p><strong>Scenario:</strong></p>
<ul>
<li>User has 5 saved adventures</li>
<li>All rated 5 stars</li>
<li>Common themes: coffee, art, culture</li>
</ul>
<p><strong>Result:</strong></p>
<ul>
<li>Query: &#34;places to visit in Cambridge&#34;</li>
<li>System prioritizes: cafes, galleries, art spaces</li>
<li>Avoids: generic tourist attractions</li>
</ul>
<p><strong>Personalization Data:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;has_history&#34;: true,
  &#34;favorite_themes&#34;: [&#34;coffee&#34;, &#34;art&#34;, &#34;culture&#34;],
  &#34;avg_rating&#34;: 4.8,
  &#34;total_adventures&#34;: 5,
  &#34;favorite_locations&#34;: [&#34;Boston&#34;, &#34;Cambridge&#34;]
}
</code></pre>
<p>Negative : Personalization requires at least 3 saved adventures for meaningful patterns to emerge</p>


      </google-codelab-step>
    
      <google-codelab-step label="Authentication &amp; Security" duration="8">
        <h2 is-upgraded>System Architecture</h2>
<p class="image-container"><img alt="Authentication Architecture" src="img\\1ed972871ad8ff56.png"></p>
<p>The authentication system uses <strong>JWT tokens</strong> with <strong>bcrypt</strong> password hashing.</p>
<h2 is-upgraded>JWT Token Flow</h2>
<p class="image-container"><img alt="Authentication Flow" src="img\\e717a3da4e2a0a2a.png"></p>
<p><strong>Registration/Login Process:</strong></p>
<ol type="1">
<li>User provides credentials</li>
<li>Password hashed with bcrypt (cost factor: 12)</li>
<li>JWT token generated (HS256 algorithm)</li>
<li>Token expires after 30 minutes</li>
</ol>
<p><strong>Token Structure:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;sub&#34;: &#34;user@example.com&#34;,
  &#34;user_id&#34;: &#34;507f1f77bcf86cd799439011&#34;,
  &#34;exp&#34;: 1640995200
}
</code></pre>
<h2 is-upgraded>Security Features</h2>
<p><strong>Password Security:</strong></p>
<ul>
<li>Algorithm: bcrypt</li>
<li>Cost factor: 12 (4096 rounds)</li>
<li>Automatic salt generation</li>
<li>Timing attack protection</li>
</ul>
<p><strong>JWT Security:</strong></p>
<ul>
<li>Algorithm: HS256</li>
<li>Secret key: 256-bit random</li>
<li>Signature verification on every request</li>
<li>Expiration checking</li>
</ul>
<p><strong>API Security:</strong></p>
<ul>
<li>CORS: Configured for specific origins</li>
<li>Rate limiting: 100 req/min (production)</li>
<li>Input validation: Pydantic models</li>
<li>XSS protection: React escapes by default</li>
</ul>
<h2 is-upgraded>Implementation</h2>
<p><strong>Password Manager:</strong></p>
<pre><code language="language-python" class="language-python">from passlib.context import CryptContext

class PasswordManager:
    def __init__(self):
        self.pwd_context = CryptContext(
            schemes=[&#34;bcrypt&#34;],
            deprecated=&#34;auto&#34;
        )
    
    def hash_password(self, password: str) -&gt; str:
        return self.pwd_context.hash(password)
    
    def verify_password(self, plain: str, hashed: str) -&gt; bool:
        return self.pwd_context.verify(plain, hashed)
</code></pre>
<p><strong>JWT Manager:</strong></p>
<pre><code language="language-python" class="language-python">from jose import jwt, JWTError

class JWTManager:
    def create_access_token(self, data: Dict) -&gt; str:
        to_encode = data.copy()
        expire = datetime.utcnow() + timedelta(minutes=30)
        to_encode[&#34;exp&#34;] = expire
        
        return jwt.encode(
            to_encode,
            self.secret_key,
            algorithm=self.algorithm
        )
</code></pre>
<h2 is-upgraded>Protected Routes</h2>
<p><strong>Frontend:</strong></p>
<pre><code language="language-typescript" class="language-typescript">const ProtectedRoute = ({ children }) =&gt; {
  const { isAuthenticated } = useAuth();
  if (!isAuthenticated) return &lt;Navigate to=&#34;/login&#34; /&gt;;
  return &lt;&gt;{children}&lt;/&gt;;
};
</code></pre>
<p><strong>Backend:</strong></p>
<pre><code language="language-python" class="language-python">@router.get(&#34;/protected&#34;)
async def protected(current_user = Depends(get_current_user)):
    return {&#34;message&#34;: &#34;Authenticated&#34;}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Database Schema" duration="8">
        <h2 is-upgraded>MongoDB Collections</h2>
<p class="image-container"><img alt="Database Schema" src="img\\d19b1786d8d15873.png"></p>
<p><strong>users Collection:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;_id&#34;: ObjectId,
  &#34;email&#34;: &#34;user@example.com&#34;,
  &#34;username&#34;: &#34;johndoe&#34;,
  &#34;hashed_password&#34;: &#34;$2b$12$...&#34;,
  &#34;total_queries&#34;: 15
}
</code></pre>
<p><strong>user_queries Collection (Lightweight):</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;user_input&#34;: &#34;coffee shops in Boston&#34;,
  &#34;adventures_count&#34;: 3,
  &#34;adventure_metadata&#34;: [
    {&#34;title&#34;: &#34;...&#34;, &#34;theme&#34;: &#34;...&#34;}
  ],
  &#34;metadata&#34;: {
    &#34;performance&#34;: {&#34;total_time_seconds&#34;: 4.2},
    &#34;research_stats&#34;: {...}
  }
}
</code></pre>
<p>Positive : <strong>Storage Philosophy:</strong> Only store full adventures when user explicitly saves - results in 97% storage reduction</p>
<p><strong>saved_adventures Collection (Full Details):</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;adventure_data&#34;: {/* complete adventure */},
  &#34;rating&#34;: 5,
  &#34;notes&#34;: &#34;Loved it!&#34;,
  &#34;tags&#34;: [&#34;coffee&#34;, &#34;art&#34;]
}
</code></pre>
<h2 is-upgraded>ChromaDB Collections</h2>
<p><strong>user_adventure_history:</strong></p>
<pre><code language="language-python" class="language-python">{
  &#34;id&#34;: &#34;user_123_adventure_1640995200&#34;,
  &#34;document&#34;: &#34;Title: Coffee Tour...&#34;,
  &#34;metadata&#34;: {&#34;user_id&#34;: &#34;user_123&#34;, &#34;rating&#34;: 5},
  &#34;embedding&#34;: [0.123, -0.456, ...]  # OpenAI
}
</code></pre>
<p><strong>dynamic_location_tips:</strong></p>
<pre><code language="language-python" class="language-python">{
  &#34;id&#34;: &#34;boston_coffee_tip_1&#34;,
  &#34;document&#34;: &#34;Local tip: Visit before 11 AM&#34;,
  &#34;metadata&#34;: {
    &#34;location&#34;: &#34;Boston&#34;,
    &#34;authenticity_score&#34;: 0.92
  }
}
</code></pre>
<h2 is-upgraded>Redis Cache</h2>
<p><strong>Structure:</strong></p>
<pre><code>Key: venue:{name}:{location}:{date}
Value: {research_data JSON}
TTL: 86400 seconds (24 hours)
</code></pre>
<p><strong>Example:</strong></p>
<pre><code>venue:Thinking Cup:Boston:2025-01-15
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="API Endpoints" duration="7">
        <h2 is-upgraded>Authentication Endpoints</h2>
<p><strong>POST /api/auth/register</strong> - Register new user <strong>POST /api/auth/login</strong> - Authenticate user <strong>GET /api/auth/me</strong> - Get current user (protected)</p>
<p><strong>Login Request:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;email&#34;: &#34;user@example.com&#34;,
  &#34;password&#34;: &#34;securepassword123&#34;
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;access_token&#34;: &#34;eyJhbGci...&#34;,
  &#34;token_type&#34;: &#34;bearer&#34;,
  &#34;user&#34;: {
    &#34;id&#34;: &#34;507f...&#34;,
    &#34;email&#34;: &#34;user@example.com&#34;
  }
}
</code></pre>
<h2 is-upgraded>Adventure Generation</h2>
<p class="image-container"><img alt="API Request Flow" src="img\\478bfca50566abf9.png"></p>
<p><strong>POST /api/adventures</strong> - Generate adventures</p>
<p><strong>Request:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;user_input&#34;: &#34;coffee shops in Boston&#34;,
  &#34;enable_progress&#34;: true
}
</code></pre>
<p><strong>Response:</strong></p>
<pre><code language="language-json" class="language-json">{
  &#34;success&#34;: true,
  &#34;adventures&#34;: [{...}, {...}, {...}],
  &#34;metadata&#34;: {
    &#34;total_time_seconds&#34;: 4.2,
    &#34;cache_hit_rate&#34;: &#34;87.5%&#34;,
    &#34;personalization_applied&#34;: true
  }
}
</code></pre>
<p><strong>Progress Updates (Streaming):</strong></p>
<pre><code language="language-json" class="language-json">{&#34;step&#34;: &#34;parse_location&#34;, &#34;progress&#34;: 0.14}
{&#34;step&#34;: &#34;research_venues&#34;, &#34;progress&#34;: 0.57}
{&#34;step&#34;: &#34;create_adventures&#34;, &#34;progress&#34;: 1.0}
</code></pre>
<h2 is-upgraded>Other Endpoints</h2>
<p><strong>Saved Adventures:</strong></p>
<ul>
<li>POST /api/saved-adventures - Save adventure</li>
<li>GET /api/saved-adventures - List saved</li>
<li>GET /api/saved-adventures/{id} - Get specific</li>
<li>PUT /api/saved-adventures/{id} - Update</li>
<li>DELETE /api/saved-adventures/{id} - Delete</li>
</ul>
<p><strong>Analytics:</strong></p>
<ul>
<li>GET /api/analytics/summary - User statistics</li>
</ul>
<p><strong>System:</strong></p>
<ul>
<li>GET /health - Health check</li>
<li>GET /api/status - Component status</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="AWS Deployment" duration="12">
        <h2 is-upgraded>Production Architecture</h2>
<p class="image-container"><img alt="AWS Deployment" src="img\\b0433d41eb0bcb15.png"></p>
<p><strong>CloudFront (Frontend):</strong></p>
<ul>
<li>URL: <code>d1nrqhtd83kmw6.cloudfront.net</code></li>
<li>Origin: S3 bucket (React build)</li>
<li>Features: GZIP, HTTP/2, global CDN</li>
</ul>
<p><strong>CloudFront (Backend):</strong></p>
<ul>
<li>URL: <code>d3ihmux7ocq5bh.cloudfront.net</code></li>
<li>Origin: Application Load Balancer</li>
<li>Routes to: ECS Fargate containers</li>
</ul>
<p><strong>ECS Fargate:</strong></p>
<ul>
<li>Auto-scaling: 1-4 tasks</li>
<li>Task specs: 1 vCPU, 2 GB RAM</li>
<li>Container: Python 3.11 + FastAPI</li>
</ul>
<p><strong>Data Layer:</strong></p>
<ul>
<li>MongoDB Atlas (M10 cluster)</li>
<li>ElastiCache Redis (Multi-AZ)</li>
<li>AWS Secrets Manager (API keys)</li>
</ul>
<h2 is-upgraded>Traffic Flow</h2>
<pre><code>User Request
    ↓
CloudFront Distribution
    ├→ Frontend: Serves React SPA from S3
    └→ Backend: Proxies API to ALB
           ↓
       ALB distributes to ECS tasks
           ↓
       FastAPI processes request
           ├→ Checks Redis cache
           ├→ Queries MongoDB
           ├→ Calls external APIs
           └→ Returns JSON response
</code></pre>
<h2 is-upgraded>Deployment Pipeline</h2>
<p class="image-container"><img alt="Deployment Pipeline" src="img\\18a6b008c0c96fae.png"></p>
<p><strong>Frontend Deployment:</strong></p>
<pre><code language="language-bash" class="language-bash"># Build
npm run build

# Sync to S3
aws s3 sync dist/ s3://bucket --delete

# Invalidate CloudFront
aws cloudfront create-invalidation \
  --distribution-id E123 --paths &#34;/*&#34;
</code></pre>
<p><strong>Backend Deployment:</strong></p>
<pre><code language="language-bash" class="language-bash"># Build &amp; push Docker image
docker build -t miniquest-backend .
docker push ECR_URL/miniquest-backend:latest

# Update ECS service
aws ecs update-service \
  --cluster miniquest-cluster \
  --service miniquest-backend \
  --force-new-deployment
</code></pre>
<h2 is-upgraded>Environment Configuration</h2>
<table>
<tr><td colspan="1" rowspan="1"><p>Variable</p>
</td><td colspan="1" rowspan="1"><p>Development</p>
</td><td colspan="1" rowspan="1"><p>Production</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>ENVIRONMENT</p>
</td><td colspan="1" rowspan="1"><p>development</p>
</td><td colspan="1" rowspan="1"><p>production</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>DEBUG</p>
</td><td colspan="1" rowspan="1"><p>true</p>
</td><td colspan="1" rowspan="1"><p>false</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>MONGODB_URL</p>
</td><td colspan="1" rowspan="1"><p>localhost</p>
</td><td colspan="1" rowspan="1"><p>Atlas M10</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>REDIS_URL</p>
</td><td colspan="1" rowspan="1"><p>localhost</p>
</td><td colspan="1" rowspan="1"><p>ElastiCache</p>
</td></tr>
</table>
<h2 is-upgraded>Monitoring</h2>
<p><strong>CloudWatch Metrics:</strong></p>
<ul>
<li>API request count</li>
<li>Response time (avg: ~4.2s)</li>
<li>Error rate (target: &lt;1%)</li>
<li>Cache hit rate (target: &gt;85%)</li>
</ul>
<p><strong>CloudWatch Alarms:</strong></p>
<ul>
<li>High error rate (&gt;5%)</li>
<li>Slow response (&gt;10s)</li>
<li>High CPU (&gt;80%)</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Local Development" duration="10">
        <h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Python 3.11+</li>
<li>Node.js 18+</li>
<li>Docker Desktop</li>
<li>API Keys: OpenAI, Tavily</li>
<li>MongoDB Atlas account (free tier OK)</li>
</ul>
<h2 is-upgraded>Quick Start with Docker</h2>
<pre><code language="language-bash" class="language-bash"># 1. Clone repository
git clone https://github.com/yourusername/miniquest
cd miniquest

# 2. Configure environment
cp .env.example .env
# Edit .env with your API keys

# 3. Start all services
docker-compose up -d

# 4. Access application
# Frontend: http://localhost:3000
# Backend: http://localhost:8000
# API Docs: http://localhost:8000/docs
</code></pre>
<h2 is-upgraded>Manual Setup</h2>
<p><strong>Backend:</strong></p>
<pre><code language="language-bash" class="language-bash">cd backend

# Create virtual environment
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Run server
uvicorn app.main:app --reload
</code></pre>
<p><strong>Frontend:</strong></p>
<pre><code language="language-bash" class="language-bash">cd frontend

# Install dependencies
npm install

# Start dev server
npm run dev
</code></pre>
<h2 is-upgraded>Environment Variables</h2>
<pre><code language="language-bash" class="language-bash"># Required
OPENAI_API_KEY=sk-...
TAVILY_API_KEY=tvly-...
MONGODB_URL=mongodb+srv://...

# Optional
GOOGLE_MAPS_KEY=AIza...
REDIS_URL=redis://localhost:6379
JWT_SECRET_KEY=random_secure_string
</code></pre>
<h2 is-upgraded>Testing</h2>
<p><strong>Backend Tests:</strong></p>
<pre><code language="language-bash" class="language-bash">cd backend

# Run all tests
pytest

# Run with coverage
pytest --cov=app tests/

# Test specific agent
pytest tests/test_tavily_research.py
</code></pre>
<p><strong>Frontend Tests:</strong></p>
<pre><code language="language-bash" class="language-bash">cd frontend

# Run tests
npm test

# Build for production
npm run build
</code></pre>
<h2 is-upgraded>Common Issues</h2>
<p><strong>CORS Error:</strong></p>
<ul>
<li>Check CORS configuration in backend</li>
<li>Verify frontend URL in allowed origins</li>
</ul>
<p><strong>JWT Token Invalid:</strong></p>
<ul>
<li>Check token expiration</li>
<li>Clear localStorage and re-login</li>
</ul>
<p><strong>Tavily Rate Limit:</strong></p>
<ul>
<li>Check cache hit rate</li>
<li>Upgrade Tavily plan if needed</li>
</ul>
<p><strong>MongoDB Connection Failed:</strong></p>
<ul>
<li>Verify MONGODB_URL</li>
<li>Check IP whitelist in MongoDB Atlas</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Frontend Components" duration="8">
        <h2 is-upgraded>Application Structure</h2>
<p><strong>Main Components:</strong></p>
<ol type="1">
<li><strong>AdventuresPage</strong> - Main generation interface<ul>
<li>Query input</li>
<li>Real-time progress tracking</li>
<li>Adventure cards display</li>
</ul>
</li>
<li><strong>ProgressTracker</strong> - Visual feedback<ul>
<li>Animated progress bar</li>
<li>Agent-specific indicators</li>
<li>Step-by-step status</li>
</ul>
</li>
<li><strong>EnhancedAdventureCard</strong> - Display adventures<ul>
<li>Header (title, theme, tagline)</li>
<li>Stats (duration, cost)</li>
<li>Researched venues</li>
<li>Itinerary timeline</li>
<li>Map integration</li>
<li>Save button</li>
</ul>
</li>
<li><strong>AnalyticsPage</strong> - User statistics<ul>
<li>Total adventures</li>
<li>Favorite themes</li>
<li>Top locations</li>
<li>Average ratings</li>
</ul>
</li>
</ol>
<h2 is-upgraded>Authentication Context</h2>
<pre><code language="language-typescript" class="language-typescript">interface AuthContextType {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  login: (email, password) =&gt; Promise&lt;void&gt;;
  logout: () =&gt; void;
}
</code></pre>
<h2 is-upgraded>Generation Flow</h2>
<pre><code language="language-typescript" class="language-typescript">const handleGenerate = async () =&gt; {
  const response = await api.post(&#39;/adventures&#39;, {
    user_input: query,
    enable_progress: true
  });
  
  // Stream progress updates
  const reader = response.body.getReader();
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    const progress = JSON.parse(
      new TextDecoder().decode(value)
    );
    setCurrentProgress(progress);
  }
  
  // Get final result
  const result = await response.json();
  setAdventures(result.adventures);
};
</code></pre>
<h2 is-upgraded>Common Components</h2>
<p><strong>Reusable UI Components:</strong></p>
<ul>
<li>BackgroundOrbs - Glassmorphism decoration</li>
<li>GlassCard - Frosted glass container</li>
<li>GlassInput - Styled input field</li>
<li>GlassButton - Styled button</li>
<li>LoadingState - Loading spinner</li>
<li>StatBadge - Metric display</li>
<li>ThemeCard - Theme ranking card</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Key Takeaways" duration="3">
        <h2 is-upgraded>What Makes MiniQuest Special</h2>
<p>Positive : <strong>Multi-Agent Design</strong> - 7 specialized agents with clear responsibilities and independent optimization</p>
<p>Positive : <strong>Real-Time Research</strong> - Tavily API provides current, accurate venue data that traditional databases can&#39;t match</p>
<p>Positive : <strong>Production-Ready</strong> - Fully deployed on AWS with CloudFront, ECS, monitoring, and auto-scaling</p>
<p>Positive : <strong>Performance Optimized</strong> - 87% faster with parallel processing, caching, and async operations</p>
<p>Positive : <strong>RAG Personalization</strong> - Learns from user preferences over time using ChromaDB embeddings</p>
<h2 is-upgraded>Technical Highlights</h2>
<ul>
<li><strong>LangGraph</strong> orchestration for complex multi-agent workflows</li>
<li><strong>Tavily API</strong> integration for real-time web research</li>
<li><strong>ChromaDB</strong> for semantic search and personalization</li>
<li><strong>Redis caching</strong> for 91% hit rate performance</li>
<li><strong>AWS CloudFront + ECS</strong> for scalable deployment</li>
<li><strong>MongoDB Atlas</strong> for flexible data storage</li>
</ul>
<h2 is-upgraded>By the Numbers</h2>
<ul>
<li><strong>7 agents</strong> working in coordination</li>
<li><strong>~50 seconds</strong> average generation time</li>
<li><strong>87% performance improvement</strong> with optimizations</li>
<li><strong>91% cache hit rate</strong> reduces API costs</li>
<li><strong>97% storage reduction</strong> with lightweight schema</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Resources &amp; Next Steps" duration="2">
        <h2 is-upgraded>Documentation</h2>
<ul>
<li><a href="https://github.com/lambdabypi/miniquest-adventure-planner" target="_blank">GitHub Repository</a></li>
<li><a href="https://d3ihmux7ocq5bh.cloudfront.net/docs" target="_blank">API Documentation</a></li>
</ul>
<h2 is-upgraded>Learn More</h2>
<ul>
<li><a href="https://python.langchain.com/docs/langgraph" target="_blank">LangGraph Documentation</a></li>
<li><a href="https://docs.tavily.com" target="_blank">Tavily API Docs</a></li>
<li><a href="https://www.mongodb.com/cloud/atlas" target="_blank">MongoDB Atlas</a></li>
<li><a href="https://fastapi.tiangolo.com" target="_blank">FastAPI</a></li>
<li><a href="https://docs.trychroma.com" target="_blank">ChromaDB</a></li>
</ul>
<h2 is-upgraded>Try It Live</h2>
<ul>
<li><strong>Frontend:</strong> https://d1nrqhtd83kmw6.cloudfront.net</li>
<li><strong>Backend API:</strong> https://d3ihmux7ocq5bh.cloudfront.net/docs</li>
<li><strong>Health Check:</strong> https://d3ihmux7ocq5bh.cloudfront.net/health</li>
</ul>
<h2 is-upgraded>Contact &amp; Feedback</h2>
<ul>
<li>GitHub: @lambdabypi</li>
<li>Email: shreyas.atneu@gmail.com</li>
</ul>
<p><strong>Thank you for exploring MiniQuest!</strong></p>
<p>Built with care using LangGraph, Tavily API, and AWS</p>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
